// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { IdRegistryEvent as IdRegistryEvent } from './id_registry_event_generated.js';
import { Message as Message } from './message_generated.js';
export var GossipVersion;
(function (GossipVersion) {
    GossipVersion[GossipVersion["V1"] = 1] = "V1";
})(GossipVersion || (GossipVersion = {}));
export var GossipContent;
(function (GossipContent) {
    GossipContent[GossipContent["NONE"] = 0] = "NONE";
    GossipContent[GossipContent["Message"] = 1] = "Message";
    GossipContent[GossipContent["IdRegistryEvent"] = 2] = "IdRegistryEvent";
    GossipContent[GossipContent["ContactInfoContent"] = 3] = "ContactInfoContent";
})(GossipContent || (GossipContent = {}));
export function unionToGossipContent(type, accessor) {
    switch (GossipContent[type]) {
        case 'NONE': return null;
        case 'Message': return accessor(new Message());
        case 'IdRegistryEvent': return accessor(new IdRegistryEvent());
        case 'ContactInfoContent': return accessor(new ContactInfoContent());
        default: return null;
    }
}
export function unionListToGossipContent(type, accessor, index) {
    switch (GossipContent[type]) {
        case 'NONE': return null;
        case 'Message': return accessor(index, new Message());
        case 'IdRegistryEvent': return accessor(index, new IdRegistryEvent());
        case 'ContactInfoContent': return accessor(index, new ContactInfoContent());
        default: return null;
    }
}
export class GossipAddressInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGossipAddressInfo(bb, obj) {
        return (obj || new GossipAddressInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGossipAddressInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GossipAddressInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    address(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    family() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startGossipAddressInfo(builder) {
        builder.startObject(3);
    }
    static addAddress(builder, addressOffset) {
        builder.addFieldOffset(0, addressOffset, 0);
    }
    static addFamily(builder, family) {
        builder.addFieldInt8(1, family, 0);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(2, port, 0);
    }
    static endGossipAddressInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // address
        return offset;
    }
    static createGossipAddressInfo(builder, addressOffset, family, port) {
        GossipAddressInfo.startGossipAddressInfo(builder);
        GossipAddressInfo.addAddress(builder, addressOffset);
        GossipAddressInfo.addFamily(builder, family);
        GossipAddressInfo.addPort(builder, port);
        return GossipAddressInfo.endGossipAddressInfo(builder);
    }
    unpack() {
        return new GossipAddressInfoT(this.address(), this.family(), this.port());
    }
    unpackTo(_o) {
        _o.address = this.address();
        _o.family = this.family();
        _o.port = this.port();
    }
}
export class GossipAddressInfoT {
    address;
    family;
    port;
    constructor(address = null, family = 0, port = 0) {
        this.address = address;
        this.family = family;
        this.port = port;
    }
    pack(builder) {
        const address = (this.address !== null ? builder.createString(this.address) : 0);
        return GossipAddressInfo.createGossipAddressInfo(builder, address, this.family, this.port);
    }
}
export class ContactInfoContent {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsContactInfoContent(bb, obj) {
        return (obj || new ContactInfoContent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsContactInfoContent(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ContactInfoContent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    peerId(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    peerIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    peerIdArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    gossipAddress(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new GossipAddressInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rpcAddress(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new GossipAddressInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    excludedHashes(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    excludedHashesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    count() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    static startContactInfoContent(builder) {
        builder.startObject(5);
    }
    static addPeerId(builder, peerIdOffset) {
        builder.addFieldOffset(0, peerIdOffset, 0);
    }
    static createPeerIdVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startPeerIdVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addGossipAddress(builder, gossipAddressOffset) {
        builder.addFieldOffset(1, gossipAddressOffset, 0);
    }
    static addRpcAddress(builder, rpcAddressOffset) {
        builder.addFieldOffset(2, rpcAddressOffset, 0);
    }
    static addExcludedHashes(builder, excludedHashesOffset) {
        builder.addFieldOffset(3, excludedHashesOffset, 0);
    }
    static createExcludedHashesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startExcludedHashesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCount(builder, count) {
        builder.addFieldInt64(4, count, BigInt('0'));
    }
    static endContactInfoContent(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // peer_id
        return offset;
    }
    unpack() {
        return new ContactInfoContentT(this.bb.createScalarList(this.peerId.bind(this), this.peerIdLength()), (this.gossipAddress() !== null ? this.gossipAddress().unpack() : null), (this.rpcAddress() !== null ? this.rpcAddress().unpack() : null), this.bb.createScalarList(this.excludedHashes.bind(this), this.excludedHashesLength()), this.count());
    }
    unpackTo(_o) {
        _o.peerId = this.bb.createScalarList(this.peerId.bind(this), this.peerIdLength());
        _o.gossipAddress = (this.gossipAddress() !== null ? this.gossipAddress().unpack() : null);
        _o.rpcAddress = (this.rpcAddress() !== null ? this.rpcAddress().unpack() : null);
        _o.excludedHashes = this.bb.createScalarList(this.excludedHashes.bind(this), this.excludedHashesLength());
        _o.count = this.count();
    }
}
export class ContactInfoContentT {
    peerId;
    gossipAddress;
    rpcAddress;
    excludedHashes;
    count;
    constructor(peerId = [], gossipAddress = null, rpcAddress = null, excludedHashes = [], count = BigInt('0')) {
        this.peerId = peerId;
        this.gossipAddress = gossipAddress;
        this.rpcAddress = rpcAddress;
        this.excludedHashes = excludedHashes;
        this.count = count;
    }
    pack(builder) {
        const peerId = ContactInfoContent.createPeerIdVector(builder, this.peerId);
        const gossipAddress = (this.gossipAddress !== null ? this.gossipAddress.pack(builder) : 0);
        const rpcAddress = (this.rpcAddress !== null ? this.rpcAddress.pack(builder) : 0);
        const excludedHashes = ContactInfoContent.createExcludedHashesVector(builder, builder.createObjectOffsetList(this.excludedHashes));
        ContactInfoContent.startContactInfoContent(builder);
        ContactInfoContent.addPeerId(builder, peerId);
        ContactInfoContent.addGossipAddress(builder, gossipAddress);
        ContactInfoContent.addRpcAddress(builder, rpcAddress);
        ContactInfoContent.addExcludedHashes(builder, excludedHashes);
        ContactInfoContent.addCount(builder, this.count);
        return ContactInfoContent.endContactInfoContent(builder);
    }
}
export class GossipMessage {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGossipMessage(bb, obj) {
        return (obj || new GossipMessage()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGossipMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GossipMessage()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    contentType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : GossipContent.NONE;
    }
    content(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    topics(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    topicsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : GossipVersion.V1;
    }
    static startGossipMessage(builder) {
        builder.startObject(4);
    }
    static addContentType(builder, contentType) {
        builder.addFieldInt8(0, contentType, GossipContent.NONE);
    }
    static addContent(builder, contentOffset) {
        builder.addFieldOffset(1, contentOffset, 0);
    }
    static addTopics(builder, topicsOffset) {
        builder.addFieldOffset(2, topicsOffset, 0);
    }
    static createTopicsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTopicsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(3, version, GossipVersion.V1);
    }
    static endGossipMessage(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // content
        builder.requiredField(offset, 8); // topics
        return offset;
    }
    static finishGossipMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedGossipMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createGossipMessage(builder, contentType, contentOffset, topicsOffset, version) {
        GossipMessage.startGossipMessage(builder);
        GossipMessage.addContentType(builder, contentType);
        GossipMessage.addContent(builder, contentOffset);
        GossipMessage.addTopics(builder, topicsOffset);
        GossipMessage.addVersion(builder, version);
        return GossipMessage.endGossipMessage(builder);
    }
    unpack() {
        return new GossipMessageT(this.contentType(), (() => {
            const temp = unionToGossipContent(this.contentType(), this.content.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.bb.createScalarList(this.topics.bind(this), this.topicsLength()), this.version());
    }
    unpackTo(_o) {
        _o.contentType = this.contentType();
        _o.content = (() => {
            const temp = unionToGossipContent(this.contentType(), this.content.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.topics = this.bb.createScalarList(this.topics.bind(this), this.topicsLength());
        _o.version = this.version();
    }
}
export class GossipMessageT {
    contentType;
    content;
    topics;
    version;
    constructor(contentType = GossipContent.NONE, content = null, topics = [], version = GossipVersion.V1) {
        this.contentType = contentType;
        this.content = content;
        this.topics = topics;
        this.version = version;
    }
    pack(builder) {
        const content = builder.createObjectOffset(this.content);
        const topics = GossipMessage.createTopicsVector(builder, builder.createObjectOffsetList(this.topics));
        return GossipMessage.createGossipMessage(builder, this.contentType, content, topics, this.version);
    }
}
//# sourceMappingURL=gossip_generated.js.map